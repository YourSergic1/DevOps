## Part 1. Инструмент ipcalc  
- Скачиваем и устанавливаем Ubuntu 20.04 Server LTS на первую виртуальную машину.  
![Установка ОС на первую машину](<screenshots/1.png>)  
- Скачиваем на машину утилиту ipclalc с помощью команды `sudo apt install ipcalc`.  
![Установка ipcalc](<screenshots/2.png>)  
1. **Сети и маски**  
	- Узнаем адрес сети 192.167.38.54/13 с помощью команды `ipcalc 192.167.38.54/13 | grep Network`.  
	![aдрес сети 192.167.38.54/13](<screenshots/3.png>)  
		- Адрес сети: **192.160.0.0**  
	- Переведем маску 255.255.255.0 в префиксную и двоичную запись с помощью команды `ipcalc 255.255.255.0 | grep Netmask`.  
	![Перевод маски](<screenshots/4.png>)  
		- В префиксной: **/24**  
		- В двоичной: **11111111.11111111.11111111.00000000**  
	- Переведем маску /15 в обычную и двоичную запись с помощью команды `ipcalc 0.0.0.0/15 | grep Netmask`.  
	![Перевод маски](<screenshots/5.png>)  
		- В обычной: **255.254.0.0**  
		- В двоичной: **11111111.11111110.00000000.00000000**  
	- Переведем маску 11111111.11111111.11111111.11110000 в обычную и префиксную запись.  
	![Перевод маски](<screenshots/6.png>)  
		- В обычной: **255.255.255.240**  
		- В префиксной: **/28**  
	- Узнаем минимальный и максимальный хост в сети 12.167.38.4 при маске /8 с помощью команды `ipcalc 12.167.38.4/8 | grep -e HostMax -e HostMin`.  
	![Максимальный и минимальный хост](<screenshots/7.png>)  
		- HostMin: **12.0.0.1**  
		- HostMax: **15.255.255.254**  
	- Узнаем минимальный и максимальный хост в сети 12.167.38.4 при маске 11111111.11111111.00000000.00000000 с помощью команды `ipcalc 12.167.38.4/16 | grep -e HostMax -e HostMin`.  
	![Максимальный и минимальный хост](<screenshots/8.png>)  
		- HostMin: **12.167.0.1**  
		- HostMax: **12.167.255.254**  
	- Узнаем минимальный и максимальный хост в сети 12.167.38.4 при маске /255.255.254.0 с помощью команды `ipcalc 12.167.38.4/255.255.254.0 | grep -e HostMax -e HostMin`.  
	![Максимальный и минимальный хост](<screenshots/9.png>)  
		- HostMin: **12.167.38.1**  
		- HostMax: **12.167.39.254**  
	- Узнаем минимальный и максимальный хост в сети 12.167.38.4 при маске /4 с помощью команды `ipcalc 12.167.38.4/4 | grep -e HostMax -e HostMin`.  
	![Максимальный и минимальный хост](<screenshots/10.png>)  
		- HostMin: **0.0.0.1**  
		- HostMax: **15.255.255.254**  
2. **localhost**  
	- **localhost** (так называемый, «местный» от англ. local, или «локальный хост», по смыслу — этот компьютер) — в компьютерных сетях, стандартное, официально зарезервированное доменное имя для частных IP-адресов (в диапазоне **127.0.0.1 — 127.255.255.254**).  
	- Определим можно ли обратиться к приложению, работающему на localhost, со следующими IP:  
		- 194.34.23.100 - **нельзя**  
		- 127.0.0.2 - **можно**  
		- 127.1.0.1 - **можно**  
		- 128.0.0.1 - **нельзя**  
3. **Диапазоны и сегменты сетей**  
	- Частные сети:  
		1) От 10.0.0.0 до 10.255.255.255 с маской 255.0.0.0 или /8  
		2) От 172.16.0.0 до 172.31.255.255 с маской 255.240.0.0 или /12  
		3) От 192.168.0.0 до 192.168.255.255 с маской 255.255.0.0 или /16  
		4) От 100.64.0.0 до 100.127.255.255 с маской подсети 255.192.0.0 или /10  
	- Определим какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных.  
		- 10.0.0.45 - **частный**  
		- 134.43.0.2 - **публичный**  
		- 192.168.4.2 - **частный**  
		- 172.20.250.4 - **частный**  
		- 172.0.2.1 -  **публичный**  
		- 192.172.0.1 -  **публичный**  
		- 172.68.0.2 -  **публичный**  
		- 172.16.255.255 - **частный**  
		- 10.10.10.10 - **частный**  
		- 192.169.168.1 -  **публичный**  
	- Определим какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18.  
	![Диапазон для хоста 10.10.0.0/18](<screenshots/11.png>)  
		- 10.0.0.1 - **нет**  
		- 10.10.0.2 - **да**  
		- 10.10.10.10 - **да**  
		- 10.10.100.1 - **нет**  
		- 10.10.1.255 - **да**  
## Part 2. Статическая маршрутизация между двумя машинами
- Склонируем первую виртуальную машину и назовем её ws-2.  
![Клонирование машины](<screenshots/12.png>)  
- Изменим для клона hostname с помощью команды `sudo hostnamectl set-hostname ws-2' и перезапустим машину.  
![Меняем hostname](<screenshots/13.png>)  
- Свяжем две машины через локальную сеть.  
![Локальное соединение машин](<screenshots/14.png>)  
- С помощью команды ip a посмотрим существующие сетевые интерфейсы.
	- ws-1 : enp0s3 - интернет, enp0s8 - внутренняя сеть  
	![ip a ws-1](<screenshots/15.png>)  
	- ws-2 : enp0s3 - интернет, enp0s8 - внутренняя сеть  
	![ip a ws-2](<screenshots/16.png>)  
- Опишем сетевой интерфейс для ws-1 с помощью команды `sudo nano /etc/netplan/00-installer-config.yaml`.  
![Описание сетевого интерфейса ws-1](<screenshots/17.png>)  
- Перезапустим сервис с помощью команды `sudo netplan apply`. И просмотрим существующие интерфейсы снова.  
![Перезапуск службы ws-1](<screenshots/18.png>)  
- Опишем сетевой интерфейс для ws-2 с помощью команды `sudo nano /etc/netplan/00-installer-config.yaml`.  
![Описание сетевого интерфейса ws-2](<screenshots/19.png>)  
- Перезапустим сервис с помощью команды `sudo netplan apply`. И просмотрим существующие интерфейсы снова.  
![Перезапуск службы ws-2](<screenshots/20.png>)  
1. **Добавление статического маршрута вручную**  
	- Добавим статический маршрут от ws-1 до ws-2 при помощи команды `sudo ip r add 172.24.116.8 dev enp0s8`. Проверим маршруты с помощью команды `ip r`.  
	![Добавление статического маршрута от ws-1 до ws-2](<screenshots/21.png>)  
	- Добавим статический маршрут от ws-2 до ws-1 при помощи команды `sudo ip r add 192.168/100.10 dev enp0s8`. Проверим маршруты с помощью команды `ip r`.  
	![Добавление статического маршрута от ws-2 до ws-1](<screenshots/22.png>)  
	- Пропингуем соединение для ws-1 с ws-2.  
	![Пингуем с ws-1](<screenshots/23.png>)  
	![Пингуем с ws-2](<screenshots/24.png>)  
2. **Добавление статического маршрута с сохранением**  
	- Перезапустим обе машины с помощью команды `reboot`.  
	- Опишем статический путь для ws-1 с помощью команды `sudo nano /etc/netplan/00-installer-config.yaml`.  
	![Добавление статического маршрута от ws-1 до ws-2 через файл](<screenshots/25.png>)  
	- Опишем статический путь для ws-2 с помощью команды `sudo nano /etc/netplan/00-installer-config.yaml`.  
	![Добавление статического маршрута от ws-2 до ws-1 через файл](<screenshots/26.png>)  
	- Пропигуем соединение для ws-1 с ws-2.  
	![Пингуем с ws-1](<screenshots/27.png>)  
	![Пингуем с ws-2](<screenshots/28.png>) 
## Part 3. Утилита iperf3  
1. **Скорость соединения**  
	- Результаты перевода:  
		- 8 Mbps = 1 MB/s  
		- 100 MB/s =  102400 KiB/s = 104857600 B/s = 838860800 b/s = 838860,8 Kb/s  
		- 1 Gbps = 1000 Mb/s  
2. **Утилита iperf3**  
	- Скачаем утилиту iperf3 на ws-1 и ws-2 с помощью команды `sudo apt install iperf3`.  
	![iperf3 ws-1](<screenshots/29.png>)  
	![iperf3 ws-2](<screenshots/30.png>)  
	- Теперь измерим скорость соединения между машинами, для этого в ws-1 введем команду `iperf3 -s`, а в ws-2 введем команду `iperf3 -c 192.168.100.10`.  
	![Работа iperf3 ws-1](<screenshots/31.png>)  
	![Работа iperf3 ws-2](<screenshots/32.png>)  
## Part 4. Сетевой экран  
1. **Утилита iptables**  
	- База утилиты iptables https://timeweb.com/ru/community/articles/nastroyka-iptables-dlya-chaynikov/.
	- С помощью команды `sudo touch /etc/firewall.sh` создадим на двух машинах скрпит, иммитирующий фаервол.  
	- С помощью команды `sudo nano /etc/firewall.sh` отредактируем созжаный файл и зададим правила.  
	![Правила ws-1](<screenshots/33.png>)  
	![Правила ws-2](<screenshots/34.png>)  
	- Откроем на машинах доступ для порта 22 (ssh) и порта 80 (http).  
	![Правила ws-1](<screenshots/35.png>)  
	![Правила ws-2](<screenshots/36.png>)  
	- Для ws-1 сначала запретим echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT), а потом разрешим echo reply (машина должна "пинговаться").  
	![Правила ws-1](<screenshots/37.png>)  
	- Для ws-2 сначала разрешим echo reply (машина должна "пинговаться"), а потом запретим echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT).  
	![Правила ws-2](<screenshots/38.png>)  
	- Запустим firewall с помощью команд `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`.  
	![Firewall ws-1](<screenshots/39.png>)  
	![Firewall ws-2](<screenshots/40.png>)  
	-Проверим работу firewall на обеих машинах, для этого пропингуем обе машины.  
	![Firewall ws-1](<screenshots/41.png>)  
	![Firewall ws-2](<screenshots/42.png>)  
		- Вторая машина пингуется, а вторая нет!  
	- **Если сначала стоит запрещающее правило, то оно имеет приоритет перед последующим разрешающим.**  
2. **Утилита nmap**  
	- Скачаем утилиту nmap с помощью команды `sudo apt install nmap`.  
	- Найдем непингующуюся машину с помощью команды `ping` и после чего утилитой nmap покажем, что хост машины запущен.  
	![Пингуем и проверяем хост ws-1](<screenshots/43.png>)  
- Сохраняем дампы образов виртуальных машин.  
## Part 5. Статическая маршрутизация сети  
- Поднимем пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2)). Соединим их внутренними сетями.  
	- r-1	
	![r-1](<screenshots/44.png>)  
	- r21	
	![r-2](<screenshots/45.png>)  
	- ws-11	 
	![ws-11](<screenshots/46.png>)  
	- ws-21	 
	![ws-21](<screenshots/47.png>)  
	- ws-22	 
	![ws-22](<screenshots/48.png>)  
1. **Настройка адресов машин**  
	- Настроим конфигурации машин в etc/netplan/00-installer-config.yaml. 
		- r-1  
		![r-1](<screenshots/49.png>)  
		- r-2  
		![r-2](<screenshots/50.png>)  
		- ws-11  
		![ws-11](<screenshots/51.png>)  
		- ws-21  
		![ws-21](<screenshots/52.png>)  
		- ws-22  
		![ws-22](<screenshots/53.png>)  
	- Перезапустим сервис с помощью команды `sudo netplan apply`. Проверим конфигурацию с помощью команды `ip -a`.  
		- r-1  
		![ip -a r-1](<screenshots/54.png>)  
		- r-2  
		![ip -a r-2](<screenshots/55.png>)  
		- ws-11  
		![ip -a ws-11](<screenshots/56.png>)  
		- ws-21  
		![ip -a ws-21](<screenshots/57.png>)  
		- ws-22  
		![ip -a ws-22](<screenshots/58.png>)  
	- Пропингуем соединения ws-22 с ws-21 с помощью команды `ping -c 5 10.20.0.10`  
	![Пингуем ws-22 и ws-21](<screenshots/59.png>)  
	- Пропингуем соединения r-1 с ws-11 с помощью команды `ping -c 5 10.20.0.2`  
	![Пингуем ws-22 и ws-21](<screenshots/60.png>)  
2. **Включение переадресации IP-адресов**  
	- Для включения переадресации выполним на r-1 и r-2 команду `ysctl -w net.ipv4.ip_forward=1`. При таком подходе переадресация не будет работать после перезагрузки системы.  
		- r-1  
		![Переадресация на r-1](<screenshots/61.png>)  
		- r-2  
		![Переадресация на r-2](<screenshots/62.png>)  
	- Откроем файл /etc/sysctl.conf и добавьим в него следующую строку: `net.ipv4.ip_forward = 1`. При использовании этого подхода, IP-переадресация включена на постоянной основе.  
		- r-1  
		![Переадресайия на r-1](<screenshots/63.png>)  
		- r-2  
		![Переадресайия на r-2](<screenshots/64.png>)  
3. **Установка маршрута по-умолчанию**  
	- Настроим маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций.  
		- ws-11  
		![Маршрут по умолчанию на ws-11](<screenshots/65.png>)  
		- ws-21  
		![Маршрут по умолчанию на ws-21](<screenshots/66.png>)  
		- ws-22  
		![Маршрут по умолчанию на ws-22](<screenshots/67.png>)  
	- С помощью команды `ip r` проверим что маршрут добавился.  
		- ws-11  
		![ip r ws-11](<screenshots/68.png>)  
		- ws-21  
		![ip r ws-21](<screenshots/69.png>)  
		- ws-22  
		![ip r ws-22](<screenshots/70.png>)  
	- Пропингуем ws-11 и r-2. С помощью команды `ping -c 5 10.100.0.12` отправим пакеты на r-1. С помощью команды `tcpdump -tn -i enp0s8` отловим пинг на r-1. 
		- ws-11: не пингуется  
		![ws-11](<screenshots/71.png>)  
		- r-2: пакеты до сети доходят  
		![r-2](<screenshots/72.png>)  
			- Это происходит так как роутеры еще не знают о существовании чего то за предлами соседних роутеров, нужно прописать статические маршруты.  
4. **Добавление статических маршрутов**  
	- Добавим в роутеры r1 и r2 статические маршруты в файле конфигураций.  
		- r-1  
		![Cтатические маршруты r-1](<screenshots/73.png>)  
		- r-2  
		![Cтатические маршруты r-2](<screenshots/74.png>)  
	- Вызовем `ip r` и покажем таблицы с маршрутами на обоих роутерах.  
		- r-1  
		![ip r r-1](<screenshots/75.png>)  
		- r-2  
		![ip r r-2](<screenshots/76.png>)  
	- Запустим команды на ws11:  
		- `ip r list 10.10.0.0/18`  
		![ip r list 10.10.0.0/18](<screenshots/77.png>)  
		- `ip r list 0.0.0.0/0`  
		![ip r list 10.10.0.0/0](<screenshots/78.png>)  
	- Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, потому что при наличии нескольких маршрутов одинаковой длины выбирается тот маршрут, который задан наиболее точно.  
5. **Построение списка маршрутизаторов**  
	- Скачаем на ws-11 утилиту traceroute с помощью команды `sudo apt install traceroute`.
	- Запустим на r1 команду дампа tcpdump `sudo tcpdump -tnv -i enp0s8`. При помощи утилиты traceroute построим список маршрутизаторов на пути от ws11 до ws21.  
		- tcpdump r-1  
		![tcpdump r-1](<screenshots/79.png>)  
		- traceroute ws-11 ws-21  
		![traceroute ws-11 ws-21](<screenshots/80.png>)  
	- Принцип работы traceroute: Утилита отправляет целевому узлу несколько пакетов с временем жизни 1 (TTL, time to live - число переходов, которые пакет может осуществить до своего исчезновения). Следующий маршрутизатор принимает пакеты и отправляет сообщение, что время жизни пакетов истекло. traceroute фиксирует адрес этого маршрутизатора и отправляет следующие пакеты, уже с TTL 2. Так, каждый раз увеличивая TTL на 1, traceroute составляет список маршрутизаторов, через которе прошли пакеты до целевого узла. Для определения промежуточных маршрутизаторов traceroute отправляет серию пакетов данных целевому узлу, при этом каждый раз увеличивая на 1 значение поля TTL («время жизни»). Это поле обычно указывает максимальное количество маршрутизаторов, которое может быть пройдено пакетом. Первый пакет отправляется с TTL, равным 1, и поэтому первый же маршрутизатор возвращает обратно сообщение ICMP, указывающее на невозможность доставки данных. Traceroute фиксирует адрес маршрутизатора, а также время между отправкой пакета и получением ответа (эти сведения выводятся на монитор компьютера). Затем traceroute повторяет отправку пакета, но уже с TTL, равным 2, что позволяет первому маршрутизатору пропустить пакет дальше.  
6. **Использование протокола ICMP при маршрутизации**  
	- Запустим на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды `tcpdump -n -i enp0s8 icmp`. Пропингуем с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды `ping -c 1 10.30.0.111`.  
		- tcpdump r-1  
		![tcpdump r-1](<screenshots/81.png>)  
		- ping c ws-11 несуществующего адреса  
		![ping c ws-11](<screenshots/82.png>)  
- Сохраняем дампы образов виртуальных машин.  
## Part 6. Статическая маршрутизация сети  
- Cкачаем isc-dhcp-server командой `sudo apt install isc-dhcp-server`.  
- Укажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r-2.  
![r-2 /etc/dhcp/dhcpd.conf](<screenshots/83.png>)  
- В файле resolv.conf пропишем nameserver 8.8.8.8.  
![r-2 resolv.conf](<screenshots/84.png>)  
- Перезагрузим службу DHCP командой `systemctl restart isc-dhcp-server`.  
![Перезагрузка DHCP](<screenshots/85.png>)  
- Машину ws21 перезагрузим при помощи `reboot` и через ip a покажем, что она получила адрес.  
![ip a ws-21](<screenshots/86.png>)  
- Пропингуем ws22 с ws21.  
![ping ws-22 c ws-21](<screenshots/87.png>)  
- Укажем MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: macaddress: 10:10:10:10:10:BA, dhcp4: true.  
![Mac адрес ws-11](<screenshots/88.png>)  
- Cкачаем isc-dhcp-server командой `sudo apt install isc-dhcp-server`.  
- Укажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r-1.  
![r-1 /etc/dhcp/dhcpd.conf](<screenshots/89.png>)  	
- В файле resolv.conf пропишем nameserver 8.8.8.8.  
![r-2 resolv.conf](<screenshots/90.png>)  
- Перезагрузим службу DHCP командой `systemctl restart isc-dhcp-server`.  
![Перезагрузка DHCP](<screenshots/91.png>)  
- Перезагрузим ws-11 и проверим mac адрес.  
![Перезагрузка ws-11](<screenshots/92.png>)  
- "Убиваем" старый адрес с помощью команды `sudo dhclient -r enp0s8`.  
![kill ip](<screenshots/93.png>)  
- Запросим обновление ip для ws-21 с помощью команды `sudo dhclient enp0s8`.  
	- ip a до запроса  
	![ip a до](<screenshots/94.png>)  
	- ip a после запроса  
	![ip a после](<screenshots/95.png>)  
- Использованные команды: `sudo dhclient -r` - убивает старый ip, `sudo dhclient` - присваивает новый ip.  
- Сохраняем дампы образов виртуальных машин.  
## Part 7. NAT  
- В данном задании используются виртуальные машины из Части 5. Восстановим машины по снимку, сделанному в пункте 5.6.  
- Скачаем утилиту Apachee2 с помощью команды `sudo apt install apache2`.  
- В файле /etc/apache2/ports.conf на ws-22 и r-1 изменим строку Listen 80 на Listen 0.0.0.0:80, то есть сделаем сервер Apache2 общедоступным.  
	- ws-22  
	![ws-22 /etc/apache2/ports.conf](<screenshots/96.png>)  
	- r-1  
	![r-1 /etc/apache2/ports.conf](<screenshots/97.png>)  
- Запустим веб-сервер Apache командой `service apache2 start` на ws22 и r1.  
	- ws-22  
	![ws-22 service apache2 start](<screenshots/98.png>)  
	- r-1  
	![r-1 service apache2 start](<screenshots/99.png>)  
- Добавим в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:  
	- Удаление правил в таблице filter - `iptables -F`;  
	- Удаление правил в таблице "NAT" - `iptables -F -t nat`;  
	- Отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`.  
- Создаем файл с помощью команды `sudo touch /etc/firewall.sh`.  
- Вносим изменения в файл с помощью команды `sudo nano /etc/firewall.sh`.  
![r-2 firewall](<screenshots/100.png>)  
- Даем права на исполнение с помощью команды `sudo chmod +x /etc/firewall.sh`.  
- Запускаем `sudo sh /etc/firewall.sh`.  
- Проверим соединение между ws22 и r1 командой ping. Пинг не удался.  
![ws-22 ping r-1](<screenshots/101.png>)  
- Добавим в файл ещё одно правило:  
	- Разрешим маршрутизацию всех пакетов протокола ICMP.  
	![r-2 firewall](<screenshots/102.png>)  
- Запускаем `sudo sh /etc/firewall.sh`.  
- Проверим соединение между ws22 и r1 командой ping. Пинг удался.  
![ws-22 ping r-1](<screenshots/103.png>)  
- Добавь в файл ещё два правила:  
	- Включи SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0).  
	- Включи DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети.  
	![r-2 firewall](<screenshots/104.png>)  
- Проверим соединение по TCP для SNAT: для этого с ws22 подключиться к серверу Apache на r1 командой: `sudo telnet 10.100.0.11 80`.  
![ws-22 telnet](<screenshots/105.png>)   
Проверь соединение по TCP для DNAT: для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080).  
![r-1 telnet](<screenshots/106.png>)   
- Сохраняем дампы образов виртуальных машин.  
## Part 8. Дополнительно. Знакомство с SSH Tunnels  
- Запустим на r2 фаервол с правилами из Части 7.  
![r-2 firewall](<screenshots/107.png>)  
- Запустим веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf изменить строку Listen 80 на Listen localhost:80) с помощью команды `sudo apache2 start`.  
![apache2 conf](<screenshots/108.png>)  
![apache2 start](<screenshots/109.png>)  
- Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21. Перед этим скачаем sshd и откроем порт 22 на ws-22.  
![port 22 ws-22](<screenshots/110.png>)  
- Подключение по тунелю с ws-21 на ws-22 с помощью команды: `ssh -L 9999:localhost:22 10.20.0.20`.  
![ssh tunel ws-21 на ws-22](<screenshots/111.png>)  
- Проверим сработало ли подключение в соседнем терминале c помощью команды: `sudo telnet 127.0.0.1 9999.  
![telnet ws-21](<screenshots/112.png>)  
- Воспользуемся Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11. Перед этим скачаем sshd и откроем порт 22 на ws-11.  
![port 22 ws-11](<screenshots/113.png>)  
- Подключение по тунелю с ws-11 на ws-22 с помощью команды: `ssh -R 8888:localhost:22 10.10.0.2`. Прописываем с ws-22.  
![ssh tunel ws-22 на ws-11](<screenshots/114.png>)  
- Проверим сработало ли подключение c помощью команды: `sudo telnet 127.0.0.1 8888.  
![telnet ws-11](<screenshots/115.png>)  
- Сохраняем дампы образов виртуальных машин.  
