# Basic CI/CD

В данном проекте мы поймем основы CI/CD.

## Part 1. Настройка gitlab-runner

- Поднимим виртуальную машину Ubuntu Server 22.04 LTS. Проверим с помощью команды `cat /etc/issue`.  
![cat /etc/issue](<resources/img/1.png>)

- Обновим все пакеты. `sudo apt update` -> `sudo apt upgrade -y`.  

- Скачаем и установим на виртуальную машину gitlab-runner `sudo apt-get install gitlab-runner`.

- Запускаем команду регистрации ранера `sudo gitlab-runner register`.  
![gitlab-runner register](<resources/img/2.png>)
- Вводим ссылку на ранер, token, вводим описание ранера, тэги, выбираем имполнителя shell.

## Part 2. Сборка

- В файле gitlab-ci.yml добавь этап запуска сборки через мейк файл из проекта C2. Файлы, полученные после сборки (артефакты), сохрани в произвольную директорию со сроком хранения 30 дней.

- Создаем в корне нашего проекта файл .gitlab-ci.yml и прописываем туда код для стадии проекта build.
![gitlab-ci.yml](<resources/img/3.png>)
- Данный yml файл выполнит команды скрипта и сохранит файлы по адресам src/cat/s21_cat и src/cat/s21_grep в течении 30 дней.  
- Не забудем скачать необходимое зависимости для сборки проекта на виртуальную машину с помощью `sudo apt update` -> `sudo apt install build-essential`.  
- Запушим изменения в репрезиторий и проверим что раннер отработает.  
![install](<resources/img/4.png>)

## Part 3. Тест кодстайла

- Напиши этап для CI, который запускает скрипт кодстайла (clang-format). Если кодстайл не прошел, то «зафейли» пайплайн. В пайплайне отобрази вывод утилиты clang-format.  

- .gitlab-ci.yml прописываем туда код для стадии проекта check-project.
![gitlab-ci.yml](<resources/img/5.png>)

- Скачаем clang-format на сервер с помощью `sudo apt-get update` -> `sudo apt-get install clang-format`.  

- Запушим изменения в репрезиторий и проверим что раннер отработает.  
![git push](<resources/img/6.png>)

- Испортим клэнг, запушим изменения в репрезиторий и и проверим что пайплайн зафейлится.  
![сломаный клэнг](<resources/img/7.png>)
![git push](<resources/img/8.png>)

- Вернем все как было.  

## Part 4. Интеграционные тесты

- Напиши этап для CI, который запускает твои интеграционные тесты из того же проекта. Запусти этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно. Если тесты не прошли, то «зафейли» пайплайн. 
В пайплайне отобрази вывод, что интеграционные тесты успешно прошли / провалились.

- .gitlab-ci.yml прописываем туда код для стадии проекта test-project.
![gitlab-ci.yml](<resources/img/9.png>)

- Запушим изменения в репрезиторий и проверим что раннер отработает.  
![git push](<resources/img/10.png>)

- Испортим тесты, запушим изменения в репрезиторий и и проверим что пайплайн зафейлится.  
![git push](<resources/img/11.png>)

- Вернем все как было.  

## Part 5. Этап деплоя

- Поднимим 2 виртуальную машину Ubuntu Server 22.04 LTS.  
![2 виртуальные машины](<resources/img/12.png>)

- Соеденим машины через внтуреннюю сеть и перезапустим.  
![внутренняя сеть](<resources/img/13.png>)

- С помощью команды ip a посмотрим существующие сетевые интерфейсы. enp0s3 - интернет, enp0s8 - внутренняя сеть.  
![ip a](<resources/img/14.png>)

- Зададим netplan для обеих машин.  
![netplan](<resources/img/15.png>)

- Перезапустим сервис с помощью команды `sudo netplan apply`. И просмотрим существующие интерфейсы снова.  
![ip a](<resources/img/16.png>)

- Пропигуем машины.  
![ping](<resources/img/17.png>)

- Теперь для беспарольного копирования с первой машины на вторую, создадим на первой машине ssh ключ и добавим во вторую.  
![ssh-keygen](<resources/img/18.png>)
![ssh-copy-id](<resources/img/19.png>)

- Скачаем пакеты для автоматического ввода пароля на первую машину `sudo apt-get install sshpass`.  

- Напишем скрипт copy-to-deploy.sh, для копирования файлов, со следующим кодом.  
![copy-to-deploy.sh](<resources/img/20.png>)

- Выдадим права titandea2 на второй машине для записи файлов.  
![chmod 777](<resources/img/21.png>)

- Проверим выполнение. Видим что deploy нужно запускать вручную.  
![manual](<resources/img/22.png>)

- Запустим deploy. Все прошло успешно.    
![manual](<resources/img/23.png>)

- Сохраним дампы образов виртуальных машин.
![дампы](<resources/img/24.png>)

## Part 6. Дополнительно. Уведомления

- Настрой уведомления об успешном/неуспешном выполнении пайплайна через бота с именем «[твой nickname] DO6 CI/CD» в Telegram.

- Создаем бота в телеграм через BotFather и получаем токен.  
![BotFather](<resources/img/25.png>)

- Теперь создадим общий чат с ботом и сделаем бота админом.  
![чат с ботом](<resources/img/26.png>)

- Теперь напишем в чат смс и через консоль узнаем id чата с помощью этой команды `curl -s "https://api.telegram.org/bot8165967461:AAFGebTH5IFvrhpsSCtw3PaFdYXbhYbFeEU/getUpdates" | jq`.  
![id чата](<resources/img/27.png>)

- Теперь зная токен бота и id чата напишем скрипт, который будет присылать смс в телеграм от имени бота.  
![скрипт бота](<resources/img/28.png>)

- Теперь вызовем данный скрипт после каждой стадии в которой нам нужно уведомление в .yml.  
![gitlab-ci.yml](<resources/img/29.png>)
![gitlab-ci.yml](<resources/img/30.png>)

- Теперь напишем еще один этап в yml файл, который будет срабаывать при фейле одной из стадий.  
![gitlab-ci.yml](<resources/img/31.png>)

- Запушим изменения и посмотри как отработает бот. Видно, что стадия при ошибке пропустилась, бот прислал 4 уведомления по 4 успешным стадиям.  
![gitlab](<resources/img/32.png>)
![бот](<resources/img/33.png>)

- Сломаем кленг и прогоним еще раз. Как видим, кленг не прошел, но прошла стадия при ошибке. Бот прислал уведомление об ошибке.  
![gitlab](<resources/img/34.png>)
![бот](<resources/img/35.png>)

- Вернем все как было.